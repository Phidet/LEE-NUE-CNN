import torch
import torch.nn.functional as F
#from tqdm import tqdm

def eval_net(net, loader, class_weights, device, combine=False):
    """Evaluation"""
    net.eval()
    n_val = len(loader)  # the number of batch
    tot = 0

    totalPixels = 0
    falsePixels = 0
    totalTrackPixels = 0
    falsePositiveTrackPixels = 0
    falseNegativeTrackPixels = 0
    trackLabelledPixels = 0

    #with tqdm(total=n_val, desc='Validation round', unit='batch', leave=True) as pbar:
    for batch in loader:
        imgs_u, true_masks_u = batch['image_u'], batch['mask_u']
        imgs_v, true_masks_v = batch['image_v'], batch['mask_v']
        imgs_w, true_masks_w = batch['image_w'], batch['mask_w']

        imgs_u = imgs_u.to(device=device, dtype=torch.float32)
        imgs_v = imgs_v.to(device=device, dtype=torch.float32)
        imgs_w = imgs_w.to(device=device, dtype=torch.float32)
        true_masks_u = true_masks_u.to(device=device, dtype=torch.long)

        with torch.no_grad():
            masks_pred_u, masks_pred_v, masks_pred_w = net(imgs_u, imgs_v, imgs_w)

        if combine:
            true_masks_v = true_masks_v.to(device=device, dtype=torch.long)
            true_masks_w = true_masks_w.to(device=device, dtype=torch.long)
            true_masks = torch.cat((true_masks_u, true_masks_v, true_masks_w))
            masks_pred = torch.cat((masks_pred_u, masks_pred_v, masks_pred_w))
        else:
            true_masks = true_masks_u
            masks_pred = masks_pred_u

        class_weights = torch.FloatTensor([1/0.425, 1/0.0692, 1/0.504]).cuda()
        num = (true_masks!=3).sum()
        class_weights[0] = torch.div(num, (true_masks==0).sum()*1.0)#.clamp(1.0, 30.0)
        class_weights[1] = torch.div(num, (true_masks==1).sum()*1.0)#.clamp(1.0, 30.0)
        class_weights[2] = torch.div(num, (true_masks==2).sum()*1.0)#.clamp(1.0, 2.0)

        tot += F.nll_loss(masks_pred, true_masks, class_weights, ignore_index=3)

        best_pred_mask = torch.argmax(masks_pred, axis=1)
        difference_mask = true_masks - best_pred_mask
        
        totalPixels += torch.sum(true_masks!=3)
        falsePixels += torch.sum(torch.logical_and(difference_mask!=0, true_masks!=3))
        totalTrackPixels += torch.sum(true_masks==1)
        trackLabelledPixels += torch.sum(torch.logical_and(best_pred_mask==1, true_masks!=3))
        falseNegativeTrackPixels += torch.sum(torch.logical_and(difference_mask!=0, true_masks==1))
        falsePositiveTrackPixels += torch.sum(torch.logical_and(torch.logical_and(best_pred_mask==1, true_masks!=1), true_masks!=3))

        #tot += F.cross_entropy(mask_pred, true_masks, weight=class_weights, ignore_index=3).item()
    #pbar.update()

    net.train()
    #print("eval ^^^^^^^ falsePositiveTrackPixels: ", falsePositiveTrackPixels, " trackLabelledPixels: ", trackLabelledPixels)
    return tot/n_val, falsePixels/(1.0*totalPixels), falseNegativeTrackPixels/(1.0*totalTrackPixels), falsePositiveTrackPixels/(1.0*trackLabelledPixels)
